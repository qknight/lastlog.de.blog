[[!meta date="2014-04-30 16:33"]]

[[!img media/nixos-lores.png alt="" style="float: right"]]

[[!tag nixos linux technology usability containerization webservice]]
[[!series webservices]]

# motivation

NixOS is all about containment. in NixOS practically every program is running in its own environment, seing only the very libraries it requires to work. as a result NixOS uses the dynamic linker very differently as every program more or less behaves like statically linked (expressed by dynamic linking to a very specific and unique path). for programming langues not using the dynamic linker (aka RPATH) there are different methods of containment like using shell scripts which export the PYTHONPATH variable for python script. **while the mentioned containment methods are well established in the NixOS community, doing the same with webservices is not.**

**the focus of this posting is about having multiple seamless webservice(s) on the same NixOS or Nix based host**. it is not about NixOps or Disnix where one could already push several webservices to several hosts on a webservice per host basis. my focus lies on finding a new way how to create isolated, individual environments which work side by side.

in this posting i want to share my thoughts about isolating webservices in the same way and discuss benefits/drawbacks of various approaches. it is also a **followup posting to [1]**. i've held a **talk about declarative webservices [2] at the easterhegg14** but since it was in german here is the english writeup.

[[!img media/advanced-webservices-on-nixos-revisited.jpg style="float: none" size=700x caption="apache as reverse proxy using vhosts, see [7] to replicate this setup"]]

# warning

<font color="red">
**please note**: nixos-containers are implemented using **systemd-nspawn** and not LXC containers. the NixOS documentation [5] warns that commands ran as root in a container might damage the host system. they are meant for development currently and not for deployment. i use them for demonstration purpose and if someone wants to use them in production it could be a good idea to implement LXC into NixOS first.
</font>
 
# new ideas for webservice packaging
 
## approach 1 (what we already have)


approach 1 is implemented in [8], where you would use httpd with a **serviceType** like **mediawiki**.  i've described this in detail in [1], so here be only the summary:

* all webservices share a common infrastructure 

    * same httpd
    * same database (but different tables)
    * are currenlty fixed to httpd (could be webserver agnostic though)

**note**: this is no news for Nixers but for devs coming from different distributions it indeed is.

### discussion

* **pro**

    * great performance
    * **everyone can host a complicated webservice with this already (if only packaged well) and i can't stress this point enough!**

* **contra**

   * **until very recently you had to chose between using this httpd abstraction OR nginx OR lighttpd**. using nixos-containers kind of 'fixed' this!
   * **very unflexible** since these services are not webserver agnostic 
   * **serviceType**s **are not reflected in the official NixOS documentation, we need to fix that!**
   * the **auto-updates currently implemented might or might not work** (this is still a bit fuzzy)
   * users of these services are likely to not understand what is going on behind the scenes
   * there are no good examples how to make use of the currently packaged **serviceType**s nor are there any unit tests to check if they work (AFAIK) - except for the mediawiki expression which is used on wiki.nixos.org

**example usage of approach 1**: see webservice3 in [7] where i made use of the mediawiki **serviceType**.

## approach 2 (what my easterhegg14 example implements)

how i think webservice composition should be approached:

* **start with an empty environment** like a nixos-container [5] (to get 'full dependencies') where the user has full control over all services and ports
* **connect all these environments together by a reverse proxy** (or something similar)

    * this is done manually in this example (but should be automated)

* **containment (containers and virtualization) helps to get flexible deployment/hosting**, its primary goal is NOT security

    * **extend nix-docker to make use of this architecture**

### example for 'approach 2' using apache as 'reverse proxy'

let's look at an excerpt from [7]:

      1	# for debugging use:
      2	#   journalctl status httpd.service
      3	#   journalctl -b -u httpd
      4	
      5	# and do not forget to start the containers manually (even the declarative containers)
      6	#
      7	# once you did nixos-rebuild switch; 
      8	# for i in `seq 1 5`; do nixos-container start web$i; done
      9	# for i in `seq 1 5`; do mkdir -p /var/lib/containers/web$i/webroot/; done
     10	# for i in `seq 1 5`; do echo "<?php phpinfo(); ?>" > /var/lib/containers/web$i/webroot/index.php; done
     11	# for i in `seq 1 5`; do echo "hello world from web$i" > /var/lib/containers/web$i/webroot/index.html; done
     12	
     13	services.httpd = {
     14	  enable = true;
     15	  enableSSL = false;
     16	  adminAddr = "web0@example.org";
     17	  virtualHosts =
     18	  [ 
     19	    # webservice0 vhost
     20	    # index.html works, browsing to index.php shows that php is not enabled
     21	    { 
     22	      serverAliases = ["webservice0"];
     23	      documentRoot = "/webroot/";
     24	      extraConfig = ''
     25	        <Directory "/webroot/">
     26	          Options -Indexes
     27	          AllowOverride None
     28	          Order allow,deny
     29	          Allow from all
     30	        </Directory>
     31	
     32	        <IfModule mod_dir.c>
     33	        DirectoryIndex index.html
     34	        </IfModule>
     35	      '';
     36	    }
     37	    # webservice1 vhost
     38	    { 
     39	      hostName = "webservice1";
     40	      serverAliases = ["webservice1"];
     41	      extraConfig = ''
     42	        # prevent a forward proxy! 
     43	        ProxyRequests off
     44	
     45	        # User-Agent / browser identification is used from the original client
     46	        ProxyVia Off
     47	        ProxyPreserveHost On 
     48	
     49	        <Proxy *>
     50	        Order deny,allow
     51	        Allow from all
     52	        </Proxy>
     53	
     54	        ProxyPass / http://192.168.101.11:80/
     55	        ProxyPassReverse / http://192.168.101.11:80/
     56	      '';
     57	    }
     58	    ## webservice2 vhost
     59	    { 
     60	      hostName = "webservice2";
     61	      serverAliases = ["webservice2"];
     62	      extraConfig = ''
     63	        # prevent a forward proxy! 
     64	        ProxyRequests off
     65	
     66	        # User-Agent / browser identification is used from the original client
     67	        ProxyVia Off
     68	        ProxyPreserveHost On 
     69	
     70	        <Proxy *>
     71	        Order deny,allow
     72	        Allow from all
     73	        </Proxy>
     74	
     75	        ProxyPass / http://192.168.102.11:80/
     76	        ProxyPassReverse / http://192.168.102.11:80/
     77	      '';
     78	    }
     79	    # webservice3 vhost
     80	    { 
     81	      hostName = "webservice3";
     82	      serverAliases = ["webservice3"];
     83	      extraConfig = ''
     84	        # prevent a forward proxy! 
     85	        ProxyRequests off
     86	
     87	        # User-Agent / browser identification is used from the original client
     88	        ProxyVia Off
     89	        ProxyPreserveHost On 
     90	
     91	        <Proxy *>
     92	        Order deny,allow
     93	        Allow from all
     94	        </Proxy>
     95	
     96	        ProxyPass / http://192.168.103.11:80/
     97	        ProxyPassReverse / http://192.168.103.11:80/
     98	      '';
     99	    }
    100	    # webservice4 vhost
    101	    { 
    102	      hostName = "webservice4";
    103	      serverAliases = ["webservice4"];
    104	      extraConfig = ''
    105	        # prevent a forward proxy! 
    106	        ProxyRequests off
    107	
    108	        # User-Agent / browser identification is used from the original client
    109	        ProxyVia Off
    110	        ProxyPreserveHost On 
    111	
    112	        <Proxy *>
    113	        Order deny,allow
    114	        Allow from all
    115	        </Proxy>
    116	
    117	        ProxyPass / http://192.168.104.11:80/
    118	        ProxyPassReverse / http://192.168.104.11:80/
    119	      '';
    120	    }
    121	    # webservice5 vhost
    122	    { 
    123	      hostName = "webservice5";
    124	      serverAliases = ["webservice5"];
    125	      extraConfig = ''
    126	        # prevent a forward proxy! 
    127	        ProxyRequests off
    128	
    129	        # User-Agent / browser identification is used from the original client
    130	        ProxyVia Off
    131	        ProxyPreserveHost On 
    132	
    133	        <Proxy *>
    134	        Order deny,allow
    135	        Allow from all
    136	        </Proxy>
    137	
    138	        ProxyPass / http://192.168.105.11:80/
    139	        ProxyPassReverse / http://192.168.105.11:80/
    140	      '';
    141	    }
    142	
    143	  ];
    144	};
    145	
    146	containers.web1 = {
    147	  privateNetwork = true;
    148	  hostAddress = "192.168.101.10";
    149	  localAddress = "192.168.101.11";
    150	  
    151	  config = { config, pkgs, ... }: { 
    152	    networking.firewall = {
    153	      enable = true;
    154	      allowedTCPPorts = [ 80 443 ];
    155	    };
    156	    services.httpd = {
    157	      enable = true;
    158	      enableSSL = false;
    159	      adminAddr = "web1@example.org";
    160	      documentRoot = "/webroot";
    161	      # we override the php version for all uses of pkgs.php with this, 
    162	      #  nix-env -qa --xml | grep php
    163	      # lists available versions of php
    164	      extraModules = [
    165	        { name = "php5"; path = "${pkgs.php}/modules/libphp5.so"; }
    166	      ];
    167	    };
    168	  };
    169	};
    170	
    171	containers.web2 = {
    172	  privateNetwork = true;
    173	  hostAddress = "192.168.102.10";
    174	  localAddress = "192.168.102.11";
    175	  
    176	  config = { config, pkgs, ... }: { 
    177	    # two additional programs are installed in the environment
    178	    environment.systemPackages = with pkgs; [
    179	      wget
    180	      nmap
    181	    ];
    182	    networking.firewall = {
    183	      enable = true;
    184	      allowedTCPPorts = [ 80 443 ];
    185	    };
    186	    services.httpd = {
    187	      enable = true;
    188	      enableSSL = false;
    189	      adminAddr = "web2@example.org";
    190	      documentRoot = "/webroot";
    191	      extraModules = [
    192	        # here we are using php-5.3.28 instead of php-5.4.23
    193	        { name = "php5"; path = "${pkgs.php53}/modules/libphp5.so"; }
    194	      ];
    195	    };
    196	  };
    197	};
    198	
    199	# container with a mediawiki instance
    200	containers.web3 = {
    201	  privateNetwork = true;
    202	  hostAddress = "192.168.103.10";
    203	  localAddress = "192.168.103.11";
    204	  
    205	  config = { config, pkgs, ... }: { 
    206	    networking.firewall = {
    207	      enable = true;
    208	      allowedTCPPorts = [ 80 443 ];
    209	    };
    210	    services.postgresql = {
    211	      enable=true;
    212	      package = pkgs.postgresql92;
    213	      authentication = pkgs.lib.mkOverride 10 ''
    214	        local mediawiki all ident map=mwusers
    215	        local all all ident
    216	      '';
    217	      identMap = ''
    218	        mwusers root   mediawiki
    219	        mwusers wwwrun mediawiki
    220	      '';
    221	    };
    222	    services.httpd = {
    223	      enable = true;
    224	      enableSSL = false;
    225	      adminAddr = "web3@example.org";
    226	      documentRoot = "/webroot";
    227	
    228	      virtualHosts =
    229	      [ 
    230	        {
    231	          serverAliases = ["webservice3"];
    232	
    233	          extraConfig = ''
    234	            RedirectMatch ^/$ /wiki
    235	          '';
    236	          extraSubservices =
    237	          [
    238	            {
    239	              serviceType = "mediawiki";
    240	              siteName = "webservice3";
    241	            }
    242	          ];
    243	        }
    244	      ];
    245	    };
    246	  };
    247	};
    248	
    249	# lighttpd hello world example
    250	containers.web4 = {
    251	  privateNetwork = true;
    252	  hostAddress = "192.168.104.10";
    253	  localAddress = "192.168.104.11";
    254	  config = { config, pkgs, ... }: { 
    255	    networking.firewall = {
    256	      enable = true;
    257	      allowedTCPPorts = [ 80 443 ];
    258	    };
    259	    services.lighttpd = {
    260	      enable = true;
    261	      document-root = "/webroot";
    262	    };
    263	  };
    264	};
    265	
    266	# nginx hello world example
    267	containers.web5 = {
    268	  privateNetwork = true;
    269	  hostAddress = "192.168.105.10";
    270	  localAddress = "192.168.105.11";
    271	  config = { config, pkgs, ... }: { 
    272	    networking.firewall = {
    273	      enable = true;
    274	      allowedTCPPorts = [ 80 443 ];
    275	    };
    276	    services.nginx = {
    277	      enable = true;
    278	      config = ''
    279	        error_log  /webroot/error.log;
    280	         
    281	        events {}
    282	         
    283	        http {
    284	          server {
    285	            access_log /webroot/access.log;
    286	            listen 80;
    287	            root /webroot;
    288	          }
    289	        }
    290	      '';
    291	    };
    292	  };
    293	};
    294	

explanation:

* when you reproduce this setup, look at line **1 to 11** and prepare your nixos-containers
* **webservice0 can be queried with curl using: "curl http://webservice0"** since the example from [7] will also write to the /etc/hosts file
* since we need named based resolver here, you might have to modify you /etc/hosts file the same way, if you don't run the webbrowser on the same host you run the reverse-proxy (this was the case for me, since i was using virtualbox for developing this setup)
* **line 37 to 140** are simple 'reverse proxy' configurations
* the declarative containers start at 146 with web1 and basically contain a container specific network setup and a firewall configuration as well as service activiations 
* **line** 193 shows how to change the used php version
* **line 222 to 245** shows how to make use of **serviceType** named **mediawik** inside a container
* **line 249** shows a hello world example for lighttpd
* **line 266** shows a hello world example for nginx

you can use this configuration by copying the needed parts into your own configuration.nix and afterwards run:

    nixos-rebuild switch

**note**: you have to adapt the extraHosts IP address.

then proceed with preparing the nixos-containers as shown in line **1 to 11**

### discussion

* **pro**

    * this would grant more freedom to domain specific language (DSL) webservers like node, mongrel, tomcat (to name a few) 
    * it integrates the concept of docker in a Nixish way
    * can be very handy when doing 'destructive' upgrades, since you can copy your container and experiment with the copied instance until you get your update script working. one could also use 'imperative containers' for this...

* **contra**

    * needs more RAM, and occupies more processes
    * longer startup times
    * since it is done manually it can be tricky to setup and debug

## approach 3: how this compares to alternatives like docker and nix-docker
what is the difference between docker and nix-docker:

* **docker on NixOS** is for handling all kinds of docker images
* **nix-docker** creates a docker image with NixOS inside that image

docker on NixOS already works pretty well. example (**run all commands as root**):

    nix-env -i docker
    docker -d 
    
then on a different shell you can start using docker:

    docker images
    docker pull ubuntu

and then run something

    docker run -t -i --privileged ubuntu:12.10 bash

docker let's you start webservices [10] from containers, like: 

    docker run -d -p 8080:80 my-site

these ports can obviously be added to the reverse-proxy setup as the internal nixos-containers.

### discussion

* **pro**

    * best level of language level package management (LL-PM) support
    * many distributions available
    * very flexible and reproducible configurations with snapshotting
    * wraps stateful packaging

* **contra**

    * requires a lot of disk space
    * docker integration in NixOS doesn't start as a system service yet (30.4.2014)

# conclusion

[[!img media/advanced-webservices-on-nixos-revisited2.jpg style="float: none" size=700x caption="when you start using docker, you system will soon look like this..."]]

related to reverse-proxy setup:

* using this reverse-proxy encapsulation isolates webservice packaging nicely

NixOS webservice ideas:

* **all declarative webservices are bound to apache (httpd) currently**
* **we do not provide good examples how to use them** (in fact, this is also true for nixos servivces in general)

## update 5.5.2014:
declaratively described webservices can be used without containersi as well. i don't like this since:

* container namespaces make port-usage straight-forward as every mysql instance would be running on the well known mysql port 3306. 

please see [11] where zef hemel did discuss this already. 

# thanks

thanks to: 

* the **shack/CCC** staff for having me at easterhegg14!
* **goibhniu**  for all the help with debugging the mediawiki expression and writing the wiki.nixos.org documentation!
* **niksnut**  for creating nixos-containers!
* **donnie berkholz**  (former gentoo dev) for his talk at fosdem14 titled "is distribution-level package management obsolete?"
* **zef hemel** for creating nix-docker and also by providing the wordpress example [9]



# links
* [1] <http://blog.lastlog.de/posts/advanced_webservices_on_nixos/>
* [2] <http://media.ccc.de/browse/conferences/eh2014/EH2014_-_5752_-_de_-_degerloch_-_201404201445_-_deklarativ_webservices_unter_nixos_beschreiben_-_joachim_schiele.html>
* [3] <http://lastlog.de/misc/easterhegg2014-docker-nix-container.svg>
* [4] <https://nixos.org/wiki/Setting_up_MediaWiki_%26_vhosts>
* [5] <http://hydra.nixos.org/build/10339703/download/2/nixos/manual.html#ch-containers>
* [6] <https://github.com/NixOS/nixos-org-configurations/blob/master/nixos-org/webserver.nix> 
* [7] <https://github.com/qknight/nixos-declarative-containers-example/blob/master/configuration.nix>
* [8] <https://github.com/NixOS/nixpkgs/blob/29027fd1e12461fc5ff5722bea79df7ff4299599/nixos/modules/services/web-servers/apache-httpd/mediawiki.nix>
* [9] <http://zef.me/6079/deploying-wordpress-using-nix-docker>
* [10] <http://www.kstaken.com/blog/2013/07/06/how-to-run-apache-under-docker/>
* [11] <http://www.infoq.com/articles/docker-containers>
